{
  "id": "28cabfa8ab96c095379d49ece0681e5eea5b5ce5",
  "poster": "data:image/png;base64,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",
  "title": "web-human",
  "knowledge": {
    "course": "基于threejs的web数字人demo\n- 模型自动居中\n- blender的工作流\n- 识别SkinnedMesh\n- MatCap & 拖动文件更新",
    "readme": "web-human",
    "author": "shadow",
    "version": "0.3"
  },
  "code": "let td = new Lab.TD([\n  'GLTFLoader',\n  'OrbitControls',\n  'ConvexHull',\n  'ConvexGeometry',\n  'fflate',\n  'EXRLoader'\n])\n\nlet scene, renderer, camera, stats\nlet model, skeleton, mixer, clock\n\n// 基础动作\nconst crossFadeControls = []\n// 代码控制基础动作播放\n// crossFadeControls[1].getValue()()\nconst intents = {\n  hello: {\n    examples: ['你好', '你好呀', '早上好', '晚上好', 'hello', 'hi'],\n    action: 'idle'\n  }\n}\n\nlet currentBaseAction = 'idle'\nconst allActions = []\nvar baseActions = {\n  idle: { weight: 1 },\n  walk: { weight: 0 },\n  run: { weight: 0 },\n  waving_pose: { weight: 0 },\n  standing_greeting_pose: { weight: 0 }\n}\nvar additiveActions = {\n  sneak_pose: { weight: 0 },\n  sad_pose: { weight: 0 },\n  agree: { weight: 0 },\n  headShake: { weight: 0 }\n}\nlet panelSettings = {\n    'modify time scale': 1.0,\n    skeleton: false,\n    exposure: 1.0,\n    color: 0xffffff // sRGB\n  },\n  numAnimations\n\nfunction gui () {\n  td.load.then(res => {\n    console.log(res)\n    clock = new THREE.Clock()\n    let clipsNameInput = Lab.ui.createTextareaInput('动画片段', () => {\n      let res = JSON.parse(clipsNameInput.getValue())\n      baseActions = res.baseActions\n      additiveActions = res.additiveActions\n    })\n    Lab.ui.add(clipsNameInput)\n    let btn = Lab.ui.createButton('打开模型', async () => {\n      openFile()\n      let clipsName = await loadAnimationsClipsFromModel()\n      baseActions = {\n        //    idle: { weight: 1 }\n      }\n      for (const c of clipsName) {\n        baseActions[c] = { weight: 0 }\n      }\n      clipsNameInput.setValue(\n        JSON.stringify({ baseActions, additiveActions }, null, 2)\n      )\n      //   btn.remove()\n      //   start()\n    })\n    Lab.ui.add(btn)\n    let startBtn = Lab.ui.createButton('开始', () => {\n      btn.remove()\n      clipsNameInput.remove()\n      startBtn.remove()\n      initInput()\n      start()\n    })\n    Lab.ui.add(startBtn)\n  })\n}\n\nfunction initInput () {\n  let input = Lab.ui.createInput('text', ':', res => getInputValueAndAction())\n  input.addEventListener('keypress', e => {\n    if (e.key.toLowerCase() === 'enter') getInputValueAndAction()\n  })\n  function getInputValueAndAction () {\n    let text = input.getValue()\n    if (text) {\n      input.setValue([''])\n      //   crossFadeControls[1].name().property\n      // crossFadeControls[0].property\n      let action = Lab.base.shuffle([\n        ...crossFadeControls.filter(\n          c => c.property != 'None' && c.property != 'idle'\n        )\n      ])[0]\n      // action.getValue()()\n      executeCrossFade(\n        baseActions.idle.action,\n        baseActions[action.property].action,\n        0.5\n      )\n      Lab.ui.toast(action.property)\n    }\n  }\n  input.style.position = 'fixed'\n  input.style.top = '90vh'\n\n  Lab.ui.add(input)\n}\n\nfunction openFile () {\n  let fp = Lab.ui.getFilePath(1)\n  if (fp && fp[0]) {\n    window._modelFilePath = fp[0]\n  }\n}\n\nfunction loadAnimationsClipsFromModel () {\n  const loader = new THREE.GLTFLoader()\n  return new Promise((resolve, reject) => {\n    let names = []\n    loader.load(window._modelFilePath, gltf => {\n      window.gltf = gltf\n      // 动画\n      const animations = gltf.animations\n\n      // 动画数量\n      let numAnimations = animations.length\n\n      for (let i = 0; i !== numAnimations; ++i) {\n        // 动画片段\n        let clip = animations[i]\n        const name = clip.name\n        names.push(name)\n        console.log(name)\n      }\n      resolve(names)\n    })\n  })\n}\n\n// 定位骨骼蒙皮\nfunction travel (group, type = 'SkinnedMesh') {\n  let res = []\n  for (let i = 0; i < group.children.length; i++) {\n    if (group.children[i].type === type) {\n      // res = group.children[i]\n      res.push(group.children[i])\n    } else {\n      let g = group.children[i]\n      if (g.children.length > 0) {\n        let cRes = travel(g)\n        res = [...res, ...cRes]\n      }\n    }\n  }\n  return res\n}\n\nfunction findSkinnedMesh (group) {\n  let sms = travel(group, 'SkinnedMesh')\n  let ms = travel(group, 'Mesh')\n  return [...sms, ...ms]\n}\n\n function dev () {\n  // let p = scene.children[3].children[0].children[1].geometry.attributes.position\n  let meshs =  findSkinnedMesh(model)\n  let box = {\n    min: { x: Infinity, y: Infinity, z: Infinity },\n    max: { x: -Infinity, y: -Infinity, z: -Infinity }\n  }\n  for (const m of meshs) {\n    if (m.geometry && !m.geometry.boundingBox) m.geometry.computeBoundingBox()\n    let mBox = m.geometry.boundingBox;\n    box.min.x = Math.min(box.min.x, mBox.min.x)\n    box.min.y = Math.min(box.min.y, mBox.min.y)\n    box.min.z = Math.min(box.min.z, mBox.min.z)\n    box.max.x = Math.max(box.max.x, mBox.max.x)\n    box.max.y = Math.max(box.max.y, mBox.max.y)\n    box.max.z = Math.max(box.max.z, mBox.max.z)\n  }\n\n  points = Lab.base.cartesian([\n    [box.min.x, box.max.x],\n    [box.min.y, box.max.y],\n    [box.min.z, box.max.z]\n  ])\n  for (var i = 0; i < points.length; i++) {\n    points[i] = new THREE.Vector3(...points[i])\n  }\n\n  // for (var i = 0; i < p.count; i++) {\n  //   // let w = p.getW(i),x=p.getX(i)/(w||1),y = p.getY(i)/(w||1), z = p.getX(i)/(w||1);\n  //   let x=p.getX(i),y = p.getY(i), z = p.getX(i);\n\n  // }\n\n  var pointSGroup = new THREE.Group()\n\n  points.forEach(point => {\n    const spGeom = new THREE.SphereGeometry(0.2)\n    const spMesh = new THREE.Mesh(spGeom, material)\n    spMesh.position.copy(point)\n    pointSGroup.add(spMesh)\n  })\n  // 将顶点添加到场景\n  scene.add(pointSGroup)\n\n  var geometry = new THREE.ConvexGeometry(points)\n  var material = new THREE.MeshBasicMaterial({ color: 0x00ff00 })\n  var mesh = new THREE.Mesh(geometry, material)\n  pointSGroup.add(mesh)\n\n  return pointSGroup\n}\n\nfunction start () {\n  let container = init(window._modelFilePath)\n  Lab.ui.add(container)\n  // animate()\n}\n\nfunction init (modelFilePath) {\n  scene = new THREE.Scene()\n  scene.background = new THREE.Color(0xa0a0a0)\n  scene.fog = new THREE.Fog(0xa0a0a0, 10, 50)\n\n  const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444)\n  hemiLight.position.set(0, 20, 0)\n  scene.add(hemiLight)\n\n  const dirLight = new THREE.DirectionalLight(0xffffff)\n  dirLight.position.set(3, 10, 10)\n  dirLight.castShadow = true\n  dirLight.shadow.camera.top = 2\n  dirLight.shadow.camera.bottom = -2\n  dirLight.shadow.camera.left = -2\n  dirLight.shadow.camera.right = 2\n  dirLight.shadow.camera.near = 0.1\n  dirLight.shadow.camera.far = 40\n  scene.add(dirLight)\n\n  // ground\n\n  const mesh = new THREE.Mesh(\n    new THREE.PlaneGeometry(1000, 1000),\n    new THREE.MeshPhongMaterial({ color: 0x999999, depthWrite: false })\n  )\n  mesh.rotation.x = -Math.PI / 2\n  mesh.receiveShadow = true\n  scene.add(mesh)\n\n  const loader = new THREE.GLTFLoader()\n\n  loader.load(modelFilePath, function (gltf) {\n    window.gltf = gltf\n    // 模型\n    model = gltf.scene\n    scene.add(model)\n\n    // 调试\n    window.scene = scene\n    // 投影\n    model.traverse(function (object) {\n      if (object.isMesh) {\n        // console.log(object)\n        // 显示\n        // var boxHelper = new THREE.BoxHelper(object, 0xffff00)\n        // scene.add(boxHelper)\n        object.castShadow = true\n      }\n    })\n\n    // matcap\n    addMatcap(model)\n\n    // 骨骼\n    skeleton = new THREE.SkeletonHelper(model)\n    skeleton.visible = false\n    scene.add(skeleton)\n\n    // 动画\n    const animations = gltf.animations\n    mixer = new THREE.AnimationMixer(model)\n    // 调试\n    window.mixer = mixer\n    // 动画数量\n    numAnimations = animations.length\n\n    for (let i = 0; i !== numAnimations; ++i) {\n      // 动画片段\n      let clip = animations[i]\n      const name = clip.name\n      console.log(name)\n\n      // Make the clip additive and remove the reference frame\n      if (baseActions[name]) {\n        // 返回所传入的剪辑参数的AnimationAction\n        const action = mixer.clipAction(clip)\n        activateAction(action)\n        baseActions[name].action = action\n        allActions.push(action)\n      } else if (additiveActions[name]) {\n        // Make the clip additive and remove the reference frame\n\n        THREE.AnimationUtils.makeClipAdditive(clip)\n\n        if (clip.name.endsWith('_pose')) {\n          clip = THREE.AnimationUtils.subclip(clip, clip.name, 2, 3, 30)\n        }\n\n        const action = mixer.clipAction(clip)\n        activateAction(action)\n        additiveActions[name].action = action\n        allActions.push(action)\n      }\n    }\n\n    // 矫正摄像机&初始化动作\n    correctionCameraAndPose()\n\n    createPanel()\n\n    animate()\n  })\n\n  renderer = new THREE.WebGLRenderer({ antialias: true })\n  renderer.setPixelRatio(window.devicePixelRatio)\n  renderer.setSize(window.innerWidth, window.innerHeight)\n  renderer.outputEncoding = THREE.sRGBEncoding\n  renderer.shadowMap.enabled = true\n\n  // tone mapping\n  // 色调映射\n  renderer.toneMapping = THREE.ACESFilmicToneMapping\n  renderer.toneMappingExposure = panelSettings.exposure\n\n  renderer.outputEncoding = THREE.sRGBEncoding\n\n  // camera\n  camera = new THREE.PerspectiveCamera(\n    45,\n    window.innerWidth / window.innerHeight,\n    1,\n    100\n  )\n  camera.position.set(-0.025, 1, 3.2)\n  window.camera = camera\n  const controls = new THREE.OrbitControls(camera, renderer.domElement)\n  controls.enablePan = false\n  controls.enableZoom = false\n  controls.target.set(0, 1, 0)\n  controls.update()\n\n  window.controls = controls\n\n  window.addEventListener('resize', onWindowResize)\n\n  Lab.ui.initDragAndDrop(document, loadFile)\n\n  return renderer.domElement\n}\n\n//\n// drag and drop anywhere in document\n//\n\nfunction updateMatcap (texture) {\n  for (const mesh of findSkinnedMesh(model)) {\n    if (mesh.material.matcap) {\n      mesh.material.matcap.dispose()\n    }\n\n    mesh.material.matcap = texture\n\n    texture.needsUpdate = true\n\n    mesh.material.needsUpdate = true // because the encoding can change\n  }\n  render()\n}\n\nfunction loadFile (file) {\n  const filename = file.name\n  const extension = filename\n    .split('.')\n    .pop()\n    .toLowerCase()\n\n  if (extension === 'exr') {\n    const reader = new FileReader()\n\n    reader.addEventListener('load', function (event) {\n      handleEXR(event)\n    })\n\n    reader.readAsArrayBuffer(file)\n  } else {\n    // 'jpg', 'png'\n\n    const reader = new FileReader()\n\n    reader.addEventListener('load', function (event) {\n      handleJPG(event)\n    })\n\n    reader.readAsDataURL(file)\n  }\n}\n\nfunction handleJPG (event) {\n  // PNG, too\n\n  function imgCallback (event) {\n    const texture = new THREE.Texture(event.target)\n\n    texture.encoding = THREE.sRGBEncoding\n\n    updateMatcap(texture)\n  }\n\n  const img = new Image()\n\n  img.onload = imgCallback\n\n  img.src = event.target.result\n}\n\nfunction handleEXR (event) {\n  const contents = event.target.result\n\n  const loader = new THREE.EXRLoader()\n\n  loader.setDataType(THREE.HalfFloatType)\n\n  const texData = loader.parse(contents)\n\n  const texture = new THREE.DataTexture()\n\n  texture.image.width = texData.width\n  texture.image.height = texData.height\n  texture.image.data = texData.data\n\n  texture.format = texData.format\n  texture.type = texData.type\n  texture.encoding = THREE.LinearEncoding\n  texture.minFilter = THREE.LinearFilter\n  texture.magFilter = THREE.LinearFilter\n  texture.generateMipmaps = false\n  texture.flipY = false\n\n  updateMatcap(texture)\n}\n\n// 矫正摄像机\n// 还有bug\nfunction correctionCameraAndPose () {\n  // 将模型的中心点设置到canvas坐标系的中心点，保证模型显示是居中的\n\n  // 有bug，y的方向问题\n  // let box = new THREE.Box3().setFromObject(model) // 获取模型的包围盒\n\n  let meshs =  findSkinnedMesh(model)\n  let box = {\n    min: { x: Infinity, y: Infinity, z: Infinity },\n    max: { x: -Infinity, y: -Infinity, z: -Infinity }\n  }\n  for (const m of meshs) {\n    if (m.geometry && !m.geometry.boundingBox) m.geometry.computeBoundingBox()\n    let mBox = m.geometry.boundingBox;\n    box.min.x = Math.min(box.min.x, mBox.min.x)\n    box.min.y = Math.min(box.min.y, mBox.min.y)\n    box.min.z = Math.min(box.min.z, mBox.min.z)\n    box.max.x = Math.max(box.max.x, mBox.max.x)\n    box.max.y = Math.max(box.max.y, mBox.max.y)\n    box.max.z = Math.max(box.max.z, mBox.max.z)\n  }\n  // console.log(box)\n  let mdlen = box.max.x - box.min.x // 模型长度\n  let mdwid = box.max.z - box.min.z // 模型宽度\n  let mdhei = box.max.y - box.min.y // 模型高度\n  let x1 = box.min.x + mdlen / 2 // 模型中心点坐标X\n  let y1 = box.min.y + mdhei / 2 // 模型中心点坐标Y\n  let z1 = box.min.z + mdwid / 2 // 模型中心点坐标Z\n\n  // 获取模型整体对角线长度,这里获取模型模型对角线的目的是为了保证模型可以完全的展示在视线范围内\n  let diagonal = Math.sqrt(\n    Math.pow(Math.sqrt(Math.pow(mdlen, 2) + Math.pow(mdwid, 2)), 2) +\n      Math.pow(mdhei, 2)\n  )\n\n  // 假设我们需要的进入视角为45度\n  controls.object.position.set(\n    box.max.x + mdwid / 2,\n    diagonal * 0.6 + Math.abs(box.max.y),\n    box.max.z + diagonal / 2\n  ) // 设置相机位置，向上偏移，确定可以包裹整个模型\n  controls.target.set(x1, y1, z1) // 设置相机的视角方向，看向模型的中心点\n  controls.update()\n\n  // 初始化动作\n  // crossFadeControls.filter(c=>c.property=='None')[0].getValue()();\n}\n\nfunction createPanel () {\n  const panel = Lab.ui.createDatGUI()\n\n  const folder1 = panel.addFolder('Base Actions 基础动作')\n  const folder2 = panel.addFolder('Additive Action Weights 动作叠加')\n  const folder3 = panel.addFolder('General Speed 全局速度')\n\n  panel\n    .addColor(panelSettings, 'color')\n    .listen()\n    .onChange(function () {\n      // model.material.color.set(panelSettings.color).convertSRGBToLinear()\n      for (const m of findSkinnedMesh(model)) {\n        m.material.color.set(panelSettings.color).convertSRGBToLinear()\n      }\n      // model.children[0].children[1].material.color.set(panelSettings.color).convertSRGBToLinear()\n      render()\n    })\n\n  panel.add(panelSettings, 'exposure', 0, 2).onChange(function () {\n    renderer.toneMappingExposure = panelSettings.exposure\n    render()\n  })\n\n  panel\n    .add(panelSettings, 'skeleton')\n    .listen()\n    .onChange(async v => {\n      // console.log(v)\n      skeleton.visible = v\n      if (v) {\n        window._box = await dev()\n      } else {\n        window._box.removeFromParent(scene)\n      }\n    })\n\n  const baseNames = ['None', ...Object.keys(baseActions)]\n\n  for (let i = 0, l = baseNames.length; i !== l; ++i) {\n    const name = baseNames[i]\n    const settings = baseActions[name]\n    panelSettings[name] = function () {\n      const currentSettings = baseActions[currentBaseAction]\n      const currentAction = currentSettings ? currentSettings.action : null\n      const action = settings ? settings.action : null\n      console.log('prepareCrossFade', currentAction, action)\n      prepareCrossFade(currentAction, action, 1)\n    }\n\n    crossFadeControls.push(folder1.add(panelSettings, name))\n  }\n\n  for (const name of Object.keys(additiveActions)) {\n    const settings = additiveActions[name]\n\n    panelSettings[name] = settings.weight\n    folder2\n      .add(panelSettings, name, 0.0, 1.0, 0.01)\n      .listen()\n      .onChange(function (weight) {\n        setWeight(settings.action, weight)\n        settings.weight = weight\n      })\n  }\n\n  folder3\n    .add(panelSettings, 'modify time scale', 0.0, 1.5, 0.01)\n    .onChange(modifyTimeScale)\n\n  folder1.open()\n  folder2.open()\n  folder3.open()\n\n  // crossFadeControls.forEach(function (control) {\n  //   control.setInactive = function () {\n  //     control.domElement.classList.add('control-inactive')\n  //   }\n\n  //   control.setActive = function () {\n  //     control.domElement.classList.remove('control-inactive')\n  //   }\n\n  //   const settings = baseActions[control.property]\n\n  //   if (!settings || !settings.weight) {\n  //     control.setInactive()\n  //   }\n  // })\n\n  window.crossFadeControls = crossFadeControls\n}\n\n// 播放动画片段\nfunction activateAction (action) {\n  const clip = action.getClip()\n  const settings = baseActions[clip.name] || additiveActions[clip.name]\n  setWeight(action, settings.weight)\n  if (clip.name === 'idle') {\n    setLoopPingPong(action)\n  } else {\n    setLoopOnce(action)\n  }\n  action.play()\n}\n\nfunction modifyTimeScale (speed) {\n  mixer.timeScale = speed\n}\n\nfunction prepareCrossFade (startAction, endAction, duration) {\n  // If the current action is 'idle', execute the crossfade immediately;\n  // else wait until the current action has finished its current loop\n  // console.log(currentBaseAction === 'idle' || !startAction || !endAction)\n  if (currentBaseAction === 'idle' || !startAction || !endAction) {\n    executeCrossFade(startAction, endAction, duration)\n  } else {\n    synchronizeCrossFade(startAction, endAction, duration)\n  }\n\n  // Update control colors\n\n  if (endAction) {\n    const clip = endAction.getClip()\n    currentBaseAction = clip.name\n  } else {\n    currentBaseAction = 'idle'\n  }\n\n  // crossFadeControls.forEach(control=> {\n  //   const name = control.property;\n  //   if (name === currentBaseAction) {\n  //     control.setActive()\n  //   } else {\n  //     control.setInactive()\n  //   }\n  // })\n}\n\nfunction synchronizeCrossFade (startAction, endAction, duration) {\n  mixer.addEventListener('loop', onLoopFinished)\n  function onLoopFinished (event) {\n    // console.log(event)\n    if (event.action === startAction) {\n      mixer.removeEventListener('loop', onLoopFinished)\n      executeCrossFade(startAction, endAction, duration)\n    }\n  }\n}\n\nfunction executeCrossFade (startAction, endAction, duration) {\n  // Not only the start action, but also the end action must get a weight of 1 before fading\n  // (concerning the start action this is already guaranteed in this place)\n\n  if (endAction) {\n    setWeight(endAction, 1)\n    endAction.time = 0\n\n    if (startAction) {\n      // Crossfade with warping\n      // console.log(startAction)\n      startAction.crossFadeTo(endAction, duration, true)\n    } else {\n      // Fade in\n      endAction.fadeIn(duration)\n    }\n  } else {\n    // Fade out\n    startAction ? startAction.fadeOut(duration) : null\n  }\n\n  let isFinished = false\n  mixer.addEventListener('finished', () => {\n    console.log('finished')\n    // !isFinished?crossFadeControls.filter(c=>c.property=='None')[0].getValue()():null;\n\n    if (isFinished === false)\n      executeCrossFade(endAction, baseActions.idle.action, 0.5)\n    isFinished = true\n  })\n}\n\n// This function is needed, since animationAction.crossFadeTo() disables its start action and sets\n// the start action's timeScale to ((start animation's duration) / (end animation's duration))\n\nfunction setWeight (action, weight) {\n  action.enabled = true\n  action.setEffectiveTimeScale(1)\n  action.setEffectiveWeight(weight)\n}\n\nfunction setLoopOnce (action) {\n  action.loop = THREE.LoopOnce\n}\n\nfunction setLoopPingPong (action) {\n  action.loop = THREE.LoopPingPong\n}\n\nfunction onWindowResize () {\n  camera.aspect = window.innerWidth / window.innerHeight\n  camera.updateProjectionMatrix()\n\n  renderer.setSize(window.innerWidth, window.innerHeight)\n}\n\nfunction animate () {\n  // Render loop\n\n  requestAnimationFrame(animate)\n\n  for (let i = 0; i !== numAnimations; ++i) {\n    const action = allActions[i]\n    if (action) {\n      const clip = action.getClip()\n      const settings = baseActions[clip.name] || additiveActions[clip.name]\n      settings.weight = action.getEffectiveWeight()\n    }\n  }\n\n  // Get the time elapsed since the last frame, used for mixer update\n\n  const mixerUpdateDelta = clock.getDelta()\n\n  // Update the animation mixer, the stats panel, and render this frame\n\n  mixer.update(mixerUpdateDelta)\n\n  // stats.update();\n\n  render()\n}\n\nfunction render () {\n  renderer.render(scene, camera)\n}\n\nfunction addMatcap (group) {\n  // manager\n  const manager = new THREE.LoadingManager(render)\n  // matcap\n  const loaderEXR = new THREE.EXRLoader(manager)\n  const matcap = loaderEXR.load('../assets/textures/matcaps/040full.exr')\n\n  // 改变材质\n  let meshs = findSkinnedMesh(group)\n  for (const m of meshs) {\n    m.material = new THREE.MeshMatcapMaterial({\n      color: new THREE.Color()\n        .setHex(panelSettings.color)\n        .convertSRGBToLinear(),\n      matcap: matcap\n      // normalMap: normalmap\n    })\n  }\n}\n",
  "code_length": 234,
  "size": [
    665,
    645
  ],
  "extname": "designlabplugin",
  "version": "0.3",
  "package_version": "0.1.2",
  "package_id": "0d66cc538861f304b963c2dda25d323740ca8d29",
  "dependencies": {
    "@ffmpeg-installer/ffmpeg": "^1.0.20",
    "@ffprobe-installer/ffprobe": "^1.1.0",
    "@fortawesome/fontawesome-free": "^5.15.3",
    "@hapi/hapi": "^20.1.2",
    "@kilokilo/three-bmfont-text": "^3.1.0",
    "@mediapipe/camera_utils": "^0.3.1632432234",
    "@mediapipe/drawing_utils": "^0.3.1620248257",
    "@mediapipe/holistic": "^0.5.1635989137",
    "@node-rs/jieba": "^1.3.1",
    "@paddlejs-models/humanseg": "0.0.5",
    "@pixiv/three-vrm": "^0.6.7",
    "@tensorflow-models/body-pix": "^2.1.0",
    "@tensorflow-models/deeplab": "^0.2.1",
    "@tensorflow-models/face-landmarks-detection": "0.0.1",
    "@tensorflow-models/knn-classifier": "^1.2.2",
    "@tensorflow-models/mobilenet": "^2.1.0",
    "@tensorflow-models/posenet": "^2.2.2",
    "@tensorflow/tfjs": "^3.3.0",
    "@tensorflow/tfjs-backend-wasm": "^3.3.0",
    "about-window": "^1.14.0",
    "animejs": "^3.2.1",
    "babylonjs": "^4.2.0",
    "babylonjs-gui": "^4.2.0",
    "babylonjs-loaders": "^4.2.0",
    "color": "^3.1.3",
    "copy-dir": "^1.3.0",
    "dat.gui": "^0.7.7",
    "debounce": "^1.2.1",
    "electron-json-storage": "^4.4.0",
    "electron-squirrel-startup": "^1.0.0",
    "emoji-picker-element": "^1.6.0",
    "emoji-regex": "^9.2.2",
    "espree": "^7.3.1",
    "exceljs": "^4.2.1",
    "face-api.js": "^0.22.2",
    "fluent-ffmpeg": "^2.1.2",
    "fomantic-ui": "^2.8.7",
    "gif.js": "^0.2.0",
    "gifuct-js": "^2.1.1",
    "horajs": "^0.1.3",
    "idb-kv-store": "^4.5.0",
    "internal-ip": "^6.2.0",
    "jimp": "^0.16.1",
    "kalidokit": "^1.0.5",
    "lowdb": "^1.0.0",
    "make-cert": "^1.2.0",
    "marked": "^1.2.9",
    "md5": "^2.3.0",
    "mime-types": "^2.1.34",
    "mkcert": "^1.5.0",
    "ml": "^6.0.0",
    "natural": "^5.0.3",
    "ngraph.path": "^1.3.1",
    "nouislider": "^14.7.0",
    "object-hash": "^2.1.1",
    "open-simplex-noise": "^2.5.0",
    "opencvjs-dist": "^4.4.0",
    "osc-js": "^2.1.2",
    "pdfjs-dist": "^2.6.347",
    "peer": "^0.6.1",
    "peerjs": "^1.3.2",
    "pixelit": "https://github.com/giventofly/pixelit.git",
    "qrcode": "^1.5.0",
    "recordrtc": "^5.6.2",
    "regl": "^2.1.0",
    "smartcrop": "^2.0.3",
    "socket.io": "^4.0.0",
    "socket.io-client": "^4.0.0",
    "three": "^0.134.0",
    "timeago.js": "^4.0.2",
    "unsplash-js": "^7.0.12",
    "wordcloud": "^1.2.2",
    "yoga-layout-wasm": "^1.9.3-alpha.7",
    "zdog": "^1.1.2"
  },
  "author": "shadow",
  "create_time": 1646728366289
}